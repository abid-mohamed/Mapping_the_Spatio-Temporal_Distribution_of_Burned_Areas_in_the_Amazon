perf.df
h2o.ls()
h2o.removeAll()
h2o:::.h2o.garbageCollect()
h2o:::.h2o.garbageCollect()
h2o:::.h2o.garbageCollect()
h2o:::.h2o.garbageCollect()
h2o:::.h2o.garbageCollect()
h2o:::.h2o.garbageCollect()
h2o:::.h2o.garbageCollect()
h2o:::.h2o.garbageCollect()
gc()
library(terra)
library(sf)
library(tidyverse)
library(terra)
library(sf)
library(tidyverse)
library(data.table)
library(dplyr)
library(gdata)
library(pROC)
# Parallel
library(foreach)
library(doSNOW)
library(parallel)
library(itertools)
# Cross Validation
library(rsample)
library(recipes)
# Plot
library(RColorBrewer)
library(tidyterra)
library(scico)
library(wesanderson)
library(viridis)
library(scales)
# library(latex2exp)
library(ggplot2)
library(plotly)
# Time
library(tictoc)
library(gdata)
library(terra)
library(sf)
library(tidyverse)
library(data.table)
library(dplyr)
library(gdata)
library(pROC)
# Parallel
library(foreach)
library(doSNOW)
library(parallel)
library(itertools)
# Cross Validation
library(rsample)
library(recipes)
# Plot
library(RColorBrewer)
library(tidyterra)
library(scico)
library(wesanderson)
library(viridis)
library(scales)
# library(latex2exp)
library(ggplot2)
library(plotly)
# Time
library(tictoc)
library(gdata)
# Import shape file
amaz.basin.shp <- st_read("~/Documents/Amazon_new_data/0. Amazon_shapefile/projected/amazon_shp_projected.shp", quiet = TRUE)
# path of variables
my.path <- "~/Documents"
path0 <- "/home/abidm/Documents"
burntArea.path <- "~/Documents/Amazon_new_data/1. Burnt Area/03. Working Data"
landCover.path <- "~/Documents/Amazon_new_data/2. Land Cover/03. Working Data"
precip.path <- "~/Documents/Amazon_new_data/3. Precipitation/03. Working Data"
soilMoisture.path <- "~/Documents/Amazon_new_data/4. Soil Moisture/03. Working Data"
elevation.path <- "~/Documents/Amazon_new_data/5. Elevation/03. Working Data"
LandSurfaceTemp.path <- "~/Documents/Amazon_new_data/6. LandSurfaceTemp/03. Working Data"
humidity.path <- "~/Documents/Amazon_new_data/7. Specific Humidity/03. Working Data"
evapotranspiration.path <- "~/Documents/Amazon_new_data/8. Evapotranspiration/03. Working Data"
wind.path <- "~/Documents/Amazon_new_data/9. Wind Speed/03. Working Data"
airtemp.path <- "~/Documents/Amazon_new_data/10. Air Temperature/03. Working Data"
# Color palette
my.colors <- c("mediumblue", "mediumseagreen", "firebrick")
pal <- colorRampPalette(c("mediumblue", "mediumseagreen", "firebrick"))
# Create a sequence of dates
sq.date <- seq(as.Date("2001-1-1"), as.Date("2020-12-1"), by = "month") %>%
format(., '%Y_%m') %>%
setdiff(., c("2012_07", "2012_09"))
zone <- 1
load(paste0(path0, "/Models_ens/Ens2_new/Ens2_performance_vi_", zone, ".Rdata"))
mv(from = 'perf.df', to = 'perf.df1')
mv(from = 'confusion.mtrx.lst', to = 'confusion.mtrx.lst1')
mv(from = 'max.metrics.lst', to = 'max.metrics.lst1')
mv(from = 'vi.lst', to = 'vi.lst1')
load(paste0(path0, "/Models_ens/Ens2_new/Ens2_performance_vi_", 11, ".Rdata"))
perf.df[1:4,] <- perf.df1[1:4,]
confusion.mtrx.lst[1:4] <- confusion.mtrx.lst1[1:4]
vi.lst[1:4] <- vi.lst1[1:4]
vi.lst
perf.df
confusion.mtrx.lst
max.metrics.lst
perf.df
save(perf.df, confusion.mtrx.lst, max.metrics.lst, vi.lst, file = paste0(path0, "/Models_ens/Ens2_new/Ens2_performance_vi_.Rdata"))
perf.df
gc()
library(terra)
library(sf)
library(tidyverse)
library(data.table)
library(dplyr)
library(gdata)
library(pROC)
# Parallel
library(foreach)
library(doSNOW)
library(parallel)
library(itertools)
# Cross Validation
library(rsample)
library(recipes)
# Plot
library(RColorBrewer)
library(tidyterra)
library(scico)
library(wesanderson)
library(viridis)
library(scales)
# library(latex2exp)
library(ggplot2)
library(plotly)
# Time
library(tictoc)
library(gdata)
# Import shape file
amaz.basin.shp <- st_read("~/Documents/Amazon_new_data/0. Amazon_shapefile/projected/amazon_shp_projected.shp", quiet = TRUE)
# path of variables
my.path <- "~/Documents"
path0 <- "/home/abidm/Documents"
burntArea.path <- "~/Documents/Amazon_new_data/1. Burnt Area/03. Working Data"
landCover.path <- "~/Documents/Amazon_new_data/2. Land Cover/03. Working Data"
precip.path <- "~/Documents/Amazon_new_data/3. Precipitation/03. Working Data"
soilMoisture.path <- "~/Documents/Amazon_new_data/4. Soil Moisture/03. Working Data"
elevation.path <- "~/Documents/Amazon_new_data/5. Elevation/03. Working Data"
LandSurfaceTemp.path <- "~/Documents/Amazon_new_data/6. LandSurfaceTemp/03. Working Data"
humidity.path <- "~/Documents/Amazon_new_data/7. Specific Humidity/03. Working Data"
evapotranspiration.path <- "~/Documents/Amazon_new_data/8. Evapotranspiration/03. Working Data"
wind.path <- "~/Documents/Amazon_new_data/9. Wind Speed/03. Working Data"
airtemp.path <- "~/Documents/Amazon_new_data/10. Air Temperature/03. Working Data"
# Color palette
my.colors <- c("mediumblue", "mediumseagreen", "firebrick")
pal <- colorRampPalette(c("mediumblue", "mediumseagreen", "firebrick"))
# Create a sequence of dates
sq.date <- seq(as.Date("2001-1-1"), as.Date("2020-12-1"), by = "month") %>%
format(., '%Y_%m') %>%
setdiff(., c("2012_07", "2012_09"))
library(matrixStats)
library(data.table)
library(dplyr)
library(sf)
library(terra)
library(recipes)
library(h2o)
library(tictoc)
#---- Initialize H2O ----
options(java.parameters = "-Xmx650g")
Sys.setenv("OPENBLAS_MAIN_FREE"=1)
h2o.init(ip = 'localhost', port = 50001, nthreads = 50, max_mem_size = '650g')
h2o.removeAll()
h2o:::.h2o.garbageCollect()
h2o:::.h2o.garbageCollect()
h2o:::.h2o.garbageCollect()
h2o.shutdown(prompt = FALSE)
#---- Initialize H2O ----
options(java.parameters = "-Xmx650g")
Sys.setenv("OPENBLAS_MAIN_FREE"=1)
h2o.init(ip = 'localhost', port = 50001, nthreads = 50, max_mem_size = '650g')
h2o.no_progress()
#---- Function ----
splitAmaZones <- function(Amazon.data.dt, amaz.basin){
#---- Initialization of zones ----
amaz.basin.shp <- st_read("/home/abidm/Documents/Amazon_new_data/0. Amazon_shapefile/projected/amazon_shp_projected.shp", quiet = TRUE)
v <- ext(amaz.basin.shp)
x.min <- v$xmin[[1]] - 1; x.max <- v$xmax[[1]] + 1;
y.min <- v$ymin[[1]] - 1; y.max <- v$ymax[[1]] + 1;
#
XY <- list(
c(x.min, -0.84e+06, y.min, y.max),                                    # z1
c(-0.84e+06, +0.55e+06,  3.75e+06,     y.max),                        # z2
c(-0.84e+06, +0.55e+06,  2.60e+06,  3.75e+06),                        # z3
c(-0.84e+06, -0.05e+06,  2.22e+06,  2.60e+06),                        # z4
c(-0.84e+06, -0.51e+06,     y.min,  2.22e+06),                        # z5
c(-0.51e+06, -0.05e+06,     y.min,  2.22e+06),                        # z6
c(-0.05e+06,  0.60e+06,     y.min,  2.60e+06),                        # z7
c( 0.60e+06,  0.95e+06,     y.min,  2.60e+06),                        # z8
c(+0.55e+06,     x.max,  3.24e+06,     y.max),                        # z9
c(+0.55e+06,     x.max,  2.86e+06,  3.24e+06),                        # z10
c(+0.55e+06,  0.95e+06,     x.max,      y.min,  2.60e+06,  2.86e+06)  # z11
)
#---- Create column `Zones` ----
Amazon.data.dt[, Zones := 0.0]
Amazon.data.dt %>% setcolorder(., c('cell', 'x', 'y', 'Zones', 'Year', 'Month')) %>% as.data.table()
nz <- length (XY)
#---- Split the data ----
for (i in 1:nz){
# cat("Zone", i, "/", nz, " - ")
if (i == nz){
# Polygon
Amazon.data.dt[((x > XY[[i]][2] & x <= XY[[i]][3]) & (y > XY[[i]][4] & y <= XY[[i]][5])) |
((x > XY[[i]][1] & x <= XY[[i]][3]) & (y > XY[[i]][5] & y <= XY[[i]][6])), Zones := i]
}else{
# Rectangle
Amazon.data.dt[(x > XY[[i]][1] & x <= XY[[i]][2]) & (y > XY[[i]][3] & y <= XY[[i]][4]), Zones := i]
}
}
#---- Compute the number of cells in each zone ----
dim.zones <- Amazon.data.dt[, .N, by=.(Zones)]
dim.zones[order(Zones)]
return(Amazon.data.dt)
}
# tic("Total")
path0 <- "/home/abidm/Documents"
burntArea.path <- paste0(path0, "/Amazon_new_data/1. Burnt Area/03. Working Data")
landCover.path <- paste0(path0, "/Amazon_new_data/2. Land Cover/03. Working Data")
precip.path <- paste0(path0, "/Amazon_new_data/3. Precipitation/03. Working Data")
soilMoisture.path <- paste0(path0, "/Amazon_new_data/4. Soil Moisture/03. Working Data")
elevation.path <- paste0(path0, "/Amazon_new_data/5. Elevation/03. Working Data")
LandSurfaceTemp.path <- paste0(path0, "/Amazon_new_data/6. LandSurfaceTemp/03. Working Data")
humidity.path <- paste0(path0, "/Amazon_new_data/7. Specific Humidity/03. Working Data")
evapotranspiration.path <- paste0(path0, "/Amazon_new_data/8. Evapotranspiration/03. Working Data")
wind.path <- paste0(path0, "/Amazon_new_data/9. Wind Speed/03. Working Data")
airtemp.path <- paste0(path0, "/Amazon_new_data/10. Air Temperature/03. Working Data")
#---- Load data ----
y_m <- c('2019', '8')
amaz.var.list <- c(
paste0(burntArea.path, '/burntarea_working_', y_m[1], '_', y_m[2], '.tif')
, paste0(landCover.path, '/landcover_working_', y_m[1], '_', y_m[2], '.tif')
, paste0(precip.path, '/precipitation_working_', y_m[1], '_', y_m[2], '.tif')
, paste0(soilMoisture.path, '/soilmoisture_working_', y_m[1], '_', y_m[2], '.tif')
, paste0(elevation.path, '/elevation_working_2019_08.tif')
, paste0(LandSurfaceTemp.path, '/landsurftemp_working_', y_m[1], '_', y_m[2], '.tif')
, paste0(humidity.path, '/humidity_working_', y_m[1], '_', y_m[2], '.tif')
, paste0(evapotranspiration.path, '/evapotranspiration_working_', y_m[1], '_', y_m[2], '.tif')
, paste0(wind.path, '/wind_working_', y_m[1], '_', y_m[2], '.tif')
, paste0(airtemp.path, '/airtemp_working_', y_m[1], '_', y_m[2], '.tif')
)
amaz.basin.shp <- st_read("/home/abidm/Documents/Amazon_new_data/0. Amazon_shapefile/projected/amazon_shp_projected.shp", quiet = TRUE)
tic("Prepare data")
nbr.z <- 11 # number of zones
# Create 'SpatRaster' object
var.ras <- rast(amaz.var.list) %>% mask(mask = amaz.basin.shp)
names(var.ras) <- c('BurntArea', 'LandCover', 'Precipitation', 'SoilMoisture', 'Elevation', 'LandSurfaceTemp', 'Humidity', 'Evapotranspiration', 'Wind', 'AirTemp')
var.ras[[c('BurntArea', 'SoilMoisture')]][var.ras[[c('BurntArea', 'SoilMoisture')]] < 0] <- NA
# Prepare data table
var0.dt <- as.data.table(var.ras, cell=T, xy=T)
var0.cells.dt <- var0.dt[, c('cell', 'x', 'y')] # to add final prediction
var.dt <- var0.dt %>%
mutate(
x = floor(x),
y = floor(y),
Year = rep(y_m[1], dim(var0.dt)[1]) %>% as.factor(),
Month = rep(y_m[2], dim(var0.dt)[1]) %>% as.factor(),
BurntArea = as.factor(BurntArea),
LandCover = as.factor(LandCover)
) %>%
na.omit() %>%
setcolorder(., c('cell', 'x', 'y', 'Year', 'Month'))
var.zones.dt <- splitAmaZones(var.dt)
var.zones.dt$Zones <- as.factor(var.zones.dt$Zones)
toc() # Prepare data: 155.852 sec elapsed
#---- Normalize data & convert to h2o ----
tic("Normalize data")
AZ_recipe <- recipe( BurntArea ~ ., data = var.zones.dt) %>%
step_normalize(all_numeric(), -c(cell, x, y))
var.norm <- AZ_recipe %>%
prep() %>%
bake(new_data = NULL) %>%
setcolorder(., c('Zones', 'cell', 'x', 'y', 'Year', 'Month', 'BurntArea')) %>%
as.data.table()
toc() # Normalize data: 14.198 sec elapsed
# Load performance
load(paste0(path0, "/Models_ens/Ens2_new/Ens2_performance_vi.Rdata"))# perf.df, confusion.mtrx.lst, max.metrics.lst, vi
# Load performance
load(paste0(path0, "/Models_ens/Ens2_new/Ens2_performance_vi.Rdata"))# perf.df, confusion.mtrx.lst, max.metrics.lst, vi
vi
# Compute beta
Metrics <- c('MSE', 'RMSE', 'LogLoss', 'Mean Per-Class Error', 'AUC', 'AUCPR', 'Gini', 'R^2')
nbr.mtrc <- length(Metrics)
beta.df <- perf.df
for (zone in 1:nbr.z){
for (mtrc in Metrics){ # mtrc <- Metrics[1]
beta.metric <- switch(
mtrc
, 'MSE'     = 1/beta.df[beta.df$Zone == zone, mtrc]
, 'RMSE'    = 1/beta.df[beta.df$Zone == zone, mtrc]
, 'LogLoss' = 1/beta.df[beta.df$Zone == zone, mtrc]
, 'Mean Per-Class Error' = 1/beta.df[beta.df$Zone == zone, mtrc]
# , 'AUC'     = beta.df[beta.df$Zone == zone, mtrc]
# , 'AUCPR'   = beta.df[beta.df$Zone == zone, mtrc]
# , 'Gini'    = beta.df[beta.df$Zone == zone, mtrc]
# , 'R^2'     = beta.df[beta.df$Zone == zone, mtrc]
)
beta.metric <- beta.df[beta.df$Zone == zone, mtrc]
beta.df[beta.df$Zone == zone, mtrc] <- beta.metric/sum(beta.metric)
}
}
beta.df
# # Load beta
# load(paste0(path0, "/Models_ens/Ens1_err/ENS1_beta.Rdata"))
# beta.m <- beta.auc
#
Models <- c('GLM', 'GBM', 'XGB', 'RF')
nbr.m <- length(Models)
p1.lst <- vector(mode='list', length=nbr.z); names(p1.lst) <- paste0('zone', 1:nbr.z)
prob.ens <- data.frame(matrix(ncol = 4, nrow = 0)); colnames(prob.ens) <- c('Zones', 'cell', 'x', 'y')
v0.dt <- var.norm[, c('Zones', 'cell', 'x', 'y')]
#---- Prepare data ----
# var.nz <- var.norm[var.norm$Zones %in% 3:7,]
# var.h2o <- as.h2o(var.nz[,-1])
#
var.nz <- var.norm
var.nz
var.h2o <- as.h2o(var.norm)
nbr.row <- dim(var.nz)[1]
prob.az = data.frame(matrix(0, nrow = nbr.row, ncol = nbr.m))
#---- Prediction ----
for (m in Models){ # m <- 'GLM'
cat("\n Model", m)
# Load model
cat(" - Load model")
model.az <- h2o.upload_model(paste0(path0, "/Models/", m, "/", m, "_AZ", zone, "_model"))
# Prediction
cat(" - Prediction")
pred.az <- h2o.predict(model.az, newdata=var.h2o)
# Probability
cat(" - Probability")
prob.az[, paste0(m)] <- as.data.table(pred.az)$p1
# Clean
h2o.rm(model.az, pred.az); h2o:::.h2o.garbageCollect()
# rm(model.az, pred.az)
}
#---- Prediction ----
for (m in Models){ # m <- 'GLM'
cat("\n Model", m)
# Load model
cat(" - Load model")
model.az <- h2o.upload_model(paste0(path0, "/Models/", m, "/", m, "_AZ", zone, "_model"))
# Prediction
cat(" - Prediction")
pred.az <- h2o.predict(model.az, newdata=var.h2o)
# Probability
cat(" - Probability")
prob.az[, paste0(m)] <- as.data.table(pred.az)$p1
# Clean
h2o.rm(model.az, pred.az); h2o:::.h2o.garbageCollect()
# rm(model.az, pred.az)
}
p1.lst[[zone]] <- v0.dt
for (mtrc in Metrics){ # mtrc <- 'AUCPR'
p1.mtrc <- Map(`*`, prob.az, beta.df[beta.df$Zone == zone, mtrc]) %>% as.data.frame() %>% rowSums() %>% as.data.table()
colnames(p1.mtrc) <- paste0('p1_z', zone,'_', mtrc)
p1.mtrc[, colnames(var.nz[, 1:4]) := var.nz[, 1:4]]
p1.lst[[zone]] <- merge.data.table(
x = p1.lst[[zone]]
, y = p1.mtrc
, by = c('Zones', 'cell', 'x', 'y')
, all = TRUE
)
rm(p1.mtrc)
}
p1.lst
h2o:::.h2o.garbageCollect()
zone.lst <- c(2:11)
for (zone in zone.lst){ # zone <- 1
cat("\n Load data Zone", zone)
tic(paste0("Zone ", zone))
zone.name <- paste0('zone', zone)
#---- Prepare data ----
# neighbors2 <- switch(
#   zone
#   , '1'  = c(1,  2, 3,  4, 5)
#   , '2'  = c(2,  1, 3,  9)
#   , '3'  = c(3,  1, 2,  4, 7, 8, 9, 10, 11)
#   , '4'  = c(4,  1, 3,  5, 6, 7)
#   , '5'  = c(5,  1, 4,  6)
#   , '6'  = c(6,  4, 5,  7)
#   , '7'  = c(7,  3, 4,  8, 11)
#   , '8'  = c(8,  3, 7, 11)
#   , '9'  = c(9,  2, 3, 10)
#   , '10' = c(10, 3, 9, 11)
#   , '11' = c(11, 3, 7,  8, 10)
# )
# var.nz <- var.norm[var.norm$Zones %in% neighbors2, ]
# var.h2o <- as.h2o(var.nz)
nbr.row <- dim(var.nz)[1]
prob.az = data.frame(matrix(0, nrow = nbr.row, ncol = nbr.m))
colnames(prob.az) = Models
#---- Prediction ----
for (m in Models){ # m <- 'GLM'
cat("\n Model", m)
# Load model
cat(" - Load model")
model.az <- h2o.upload_model(paste0(path0, "/Models/", m, "/", m, "_AZ", zone, "_model"))
# Prediction
cat(" - Prediction")
pred.az <- h2o.predict(model.az, newdata=var.h2o)
# Probability
cat(" - Probability")
prob.az[, paste0(m)] <- as.data.table(pred.az)$p1
# Clean
h2o.rm(model.az, pred.az); h2o:::.h2o.garbageCollect()
# rm(model.az, pred.az)
}
#---- Compute the probability P(X=1) ----
cat(" - beta")
p1.lst[[zone]] <- v0.dt
for (mtrc in Metrics){ # mtrc <- 'AUCPR'
p1.mtrc <- Map(`*`, prob.az, beta.df[beta.df$Zone == zone, mtrc]) %>% as.data.frame() %>% rowSums() %>% as.data.table()
colnames(p1.mtrc) <- paste0('p1_z', zone,'_', mtrc)
p1.mtrc[, colnames(var.nz[, 1:4]) := var.nz[, 1:4]]
p1.lst[[zone]] <- merge.data.table(
x = p1.lst[[zone]]
, y = p1.mtrc
, by = c('Zones', 'cell', 'x', 'y')
, all = TRUE
)
rm(p1.mtrc)
}
cat("\n"); toc()
# Zone1: 1046.236 sec elapsed
# Zone2: 1032.611 sec elapsed
# Zone3: 1218.157 sec elapsed
# Zone4: 914.38 sec elapsed
# Zone5: 574.383 sec elapsed
# Zone6: 209.042 sec elapsed
# Zone7: 534.735 sec elapsed
# Zone8: 455.821 sec elapsed
# Zone9: 737.361 sec elapsed
# Zone10: 595.125 sec elapsed
# Zone11: 534.601 sec elapsed
h2o:::.h2o.garbageCollect()
} # Toral:  ~ 2.2 h
pred.az
var.h2o
prob.az[, paste0(m)] <- pred.az$p1
pred.az$p1
prob.h2o <- pred.az$p1
prob.h2o
p1.lst
zone
var.h2o
prob.h2o <- var.h2o[, c('Zones', 'cell', 'x', 'y')]
prob.h2o
paste0(model, zone)
paste0(m, zone)
paste0('p1_', m, zone)
paste0('p1_', m, 'z', zone)
aste0('p1_', m, '_z', zone)
paste0('p1_', m, '_z', zone)
prob.h2o[, paste0('p1_', m, '_z', zone)] <- pred.az$p1
prob.h2o
var.h2o
prob.h2o[, -c('Zones', 'cell', 'x', 'y')]
prob.h2o[, -c(1:4)]
beta.df[beta.df$Zone == zone, mtrc]
prob.h2o <- var.h2o[, c('Zones', 'cell', 'x', 'y')]
zone <- 1
zone.name <- paste0('zone', zone)
#---- Prepare data ----
nbr.row <- dim(var.nz)[1]
# prob.az = data.frame(matrix(0, nrow = nbr.row, ncol = nbr.m))
colnames(prob.az) = Models
#---- Prediction ----
for (m in Models){ # m <- 'GLM'
cat("\n Model", m)
# Load model
cat(" - Load model")
model.az <- h2o.upload_model(paste0(path0, "/Models/", m, "/", m, "_AZ", zone, "_model"))
# Prediction
cat(" - Prediction")
pred.az <- h2o.predict(model.az, newdata=var.h2o)
# Probability
cat(" - Probability")
prob.h2o[, paste0('p1_', m, '_z', zone)] <- pred.az$p1
# Clean
h2o.rm(model.az, pred.az); h2o:::.h2o.garbageCollect()
# rm(model.az, pred.az)
}
prob.h2o
Map(`*`, prob.h2o[, -c(1:4)], beta.df[beta.df$Zone == zone, mtrc])
prob.h2o
beta.df[beta.df$Zone == zone, mtrc]
Map(`*`, prob.h2o[, -c(1:4)], beta.df[beta.df$Zone == zone, mtrc]) %>% rowSums()
Map(`*`, prob.h2o[, -c(1:4)], beta.df[beta.df$Zone == zone, mtrc])
mtrc
mtrc <- 'AUCPR'
#---- Compute the probability P(X=1) ----
mtrc <- 'AUCPR'
p1.ens <- Map(`*`, prob.h2o[, -c(1:4)], beta.df[beta.df$Zone == zone, mtrc])
p1.ens
p1.ens
mtrc
prob.h2o[, -c(1:4)]
system.time(prob.az <- prob.h2o[, -c(1:4)])
system.time(prob.az <- as.matrix(prob.h2o[, -c(1:4)]))
reticulate::repl_python()
prob.h2o
